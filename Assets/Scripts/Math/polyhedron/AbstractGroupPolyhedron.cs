using System;
using System.Collections;
using System.Collections.Generic;
using System.IO.IsolatedStorage;
using System.Linq;
using System.Xml.Linq;
using Unity.VisualScripting;
using UnityEngine;
using static UnityEditor.IMGUI.Controls.PrimitiveBoundsHandle;

/// <summary>
/// A polyhedron with symmetry group generated by two elements:
/// 1. A vertex stabilizer,
/// 2. A face stabilizer.
/// </summary>

// TODO: This should be completely serializable. Should contain rotations axes.
[System.Serializable]
public class AbstractGroupPolyhedron : AbstractPolyhedron
{

    private readonly IsometryGroup group;
    private List<Vector3> axes;

    public int vertexDegree { get; private set; }

    // TODO: Move somewhere else
    #region --------------- (static) Projections ---------------
    
    public static Vector3 Aug4to3(params float[] x)
    {
        return new Vector3(
            (x[0] - x[1]) / Mathf.Sqrt(2),
            (x[0] + x[1] - 2 * x[2]) / Mathf.Sqrt(6),
            (x[0] + x[1] + x[2] - 3 * x[3]) / Mathf.Sqrt(12)
            );
    }

    public static Vector3 ProjOfAug5to4(params float[] x)
    {
        float[] point4 = new float[] {
            (x[0] - x[1]) / Mathf.Sqrt(2),
            (x[0] + x[1] - 2 * x[2]) / Mathf.Sqrt(6),
            (x[0] + x[1] + x[2] - 3 * x[3]) / Mathf.Sqrt(12),
            (x[0] + x[1] + x[2] + x[3] - 4 * x[4]) / Mathf.Sqrt(20)
        };

        float r = Mathf.Sqrt(point4[0] * point4[0] + point4[1] * point4[1] + point4[2] * point4[2] + point4[3] * point4[3]);
        point4[0] /= r;
        point4[1] /= r;
        point4[2] /= r;
        point4[3] /= r;

        float alpha = 1-point4[3];
        return new Vector3(point4[1]/alpha, point4[2]/alpha, point4[0]/alpha);
    }

    #endregion


    #region --------------- Polyhedron types ---------------

    public static AbstractGroupPolyhedron Cube(float radius)
    {
        Vector3 v = new Vector3(1, 1, 1);
        v *= radius / Mathf.Sqrt(3);

        return new AbstractGroupPolyhedron(
            Matrix.Rotation3(1, 1, 1, 2 * Mathf.PI / 3),        // vertex stabilizer
            Matrix.Rotation3(1, 0, 0, Mathf.PI / 2),            // face stabilizer
            v);
    }

    public static AbstractGroupPolyhedron Octahedron(float radius)
    {
        Vector3 v = new Vector3(0, radius, 0);

        return new AbstractGroupPolyhedron(
            Matrix.Rotation3(0, 1, 0, Mathf.PI / 2),            // vertex stabilizer
            Matrix.Rotation3(1, 1, 1, 2 * Mathf.PI / 3),        // face stabilizer
            v);
    }

    public static AbstractGroupPolyhedron Tetrahedron(float radius)
    {
        Vector3 v = new Vector3(0, radius, 0);

        return new AbstractGroupPolyhedron(
            Matrix.Rotation3(0, 1, 0, 2 * Mathf.PI / 3),                // vertex stabilizer
            Matrix.Rotation3(0, 1, Mathf.Sqrt(8), 2 * Mathf.PI / 3),    // face stabilizer
            v);
    }

    public static AbstractGroupPolyhedron Dodecahedron(float radius)
    {
        Vector3 v = new Vector3(1, 1, 1);
        v *= radius / Mathf.Sqrt(3);

        float phi = (1 + Mathf.Sqrt(5)) / 2;
        return new AbstractGroupPolyhedron(
            Matrix.Rotation3(1, 1, 1, 2 * Mathf.PI / 3),        // vertex stabilizer
            Matrix.Rotation3(1, phi, 0, 2 * Mathf.PI / 5),        // face stabilizer
            v);
    }

    public static AbstractGroupPolyhedron Isocahedron(float radius)
    {
        float phi = (1 + Mathf.Sqrt(5)) / 2;

        Vector3 v = new Vector3(0, 1, phi);
        v *= radius / v.magnitude;

        return new AbstractGroupPolyhedron(
            Matrix.Rotation3(0, 1, phi, 2 * Mathf.PI / 5),        // vertex stabilizer
            Matrix.Rotation3(1, 1, 1,   2 * Mathf.PI / 3),        // face stabilizer
            v);
    }

    #endregion

    public AbstractGroupPolyhedron(Matrix vertexStabilizerMatrix, Matrix faceStabilizerMatrix, Vector3 vertex)
    {
        group = IsometryGroup.GenerateFullGroup(vertexStabilizerMatrix, faceStabilizerMatrix);
        // Create all the vertices, and connect them to the vertex stabilizer cosets

        // TODO find a better way to extract the generators
        IsoElement verRotation = group.AddElement(vertexStabilizerMatrix);                      // generating element
        Group<IsoElement> verStabilizer = group.Subgroup(verRotation);                          // full stabilizer
        // TODO: Right now, subgroup is not a "finite group", so it doesn't have a size. Fix this.
        vertexDegree = 0;
        foreach (var _ in verStabilizer)
        {
            vertexDegree += 1;
        }
        
        IEnumerable<IsoElement> verCosets = group.CosetRepresentatives(verStabilizer);          // cosets

        Dictionary<IsoElement, int> cosetRepToIndex = new Dictionary<IsoElement, int>();

        foreach (IsoElement element in verCosets)
        {
            cosetRepToIndex.Add(element, AddVertex(element * vertex, $"Vertex({element.Name})"));
        }


        // Create all the faces

        IsoElement faceRotation = group.AddElement(faceStabilizerMatrix);                       // generating element
        Group<IsoElement> faceStabilizer = group.Subgroup(faceRotation);                        // full stabilizer
        IEnumerable<IsoElement> faceCosets = group.CosetRepresentatives(faceStabilizer);        // cosets

        // Since we actually need the elements in the stabilizer ordered around the face
        IsoElement identity = faceStabilizer.Identity();
        List<IsoElement> orderedStabilizer = new List<IsoElement> { identity };
        IsoElement g = faceRotation;
        for (int i = 0; i < FiniteGroup<IsoElement>.MAX_ITERATIONS; i++)
        {
            if (g == identity)
                break;
            orderedStabilizer.Add(g);
            g *= faceRotation;
        }

        foreach (var faceCoset in faceCosets)
        {
            List<int> faceVertexIndices = new List<int>();
            foreach (var elem in orderedStabilizer)
            {
                IsoElement verRep = group.FindCosetRepresentative(faceCoset * elem, verCosets, verStabilizer);
                if (!cosetRepToIndex.TryGetValue(verRep, out int index))
                {
                    Debug.Log("You should not be here");
                    return;
                }
                faceVertexIndices.Add(index);
            }
            AddFace(faceVertexIndices, $"Face({faceCoset.Name})", Vector3.zero);
        }

        ComputeRotationAxes();
    }

    private void ComputeRotationAxes()
    {
        axes = new List<Vector3>();
        foreach (IsoElement g in group)
        {
            if (g == group.Identity())
                continue;
            g.GetPresentation(out Vector3 axis, out _);
            axes.Add(axis.normalized);
        }
    }

    public bool NearRotationAxis(Vector3 v, float error)
    {
        v = v.normalized;
        foreach (var axis in axes)
        {
            if ((axis - v).magnitude < error || (axis + v).magnitude < error)
                return true;
        }
        return false;
    }

    /*

    public AbstractGroupPolyhedron(float radius)
    {
        IsometryGroup group = IsometryGroup.GenerateFullGroup(
            Matrix.Rotation3(1, 1, 1, 2 * Mathf.PI / 3),        // vertex stabilizer
            Matrix.Rotation3(1, 0, 0, Mathf.PI / 2)             // face stabilizer
            );

        // Create all the vertices, and connect them to the vertex stabilizer cosets

        Vector3 v = new Vector3(1, 1, 1);
        v *= radius / Mathf.Sqrt(3);

        // TODO find a better way to extract the generators
        IsoElement verRotation = group.AddElement(Matrix.Rotation3(1, 1, 1, 2 * Mathf.PI / 3));     // generating element
        Group<IsoElement> verStabilizer = group.Subgroup(verRotation);                          // full stabilizer
        IEnumerable<IsoElement> verCosets = group.CosetRepresentatives(verStabilizer);          // cosets

        Dictionary<IsoElement, int> cosetRepToIndex = new Dictionary<IsoElement, int>();

        foreach (IsoElement element in verCosets)
        {
            cosetRepToIndex.Add(element, AddVertex(element * v, $"Vertex({element.Name})"));
        }


        // Create all the faces

        IsoElement faceRotation = group.AddElement(Matrix.Rotation3(1, 0, 0, Mathf.PI / 2));    // generating element
        Group<IsoElement> faceStabilizer = group.Subgroup(faceRotation);                        // full stabilizer
        IEnumerable<IsoElement> faceCosets = group.CosetRepresentatives(faceStabilizer);        // cosets

        foreach (var faceCoset in faceCosets)
        {
            List<int> faceVertexIndices = new List<int>();
            foreach (var elem in faceStabilizer)
            {
                IsoElement verRep = group.FindCosetRepresentative(faceCoset * elem, verCosets, verStabilizer);
                if (!cosetRepToIndex.TryGetValue(verRep, out int index))
                {
                    Debug.Log("You should not be here");
                    return;
                }
                faceVertexIndices.Add(index);
            }
            AddFace(faceVertexIndices, $"Face({faceCoset.Name})", Vector3.zero);
        }
    }*/

    public void AbstractDodecahedron2(float radius)
    {

        SymmetryElement elem5 = SymmetryElement.Identity(4) * 5;

        HashSet<SymmetryElement> fullGroup = SymmetryElement.AlternatingGroup(5);

        //SymmetryElement verRotation = new SymmetryElement(1, 2, 0, 3);
        SymmetryElement verRotation = new SymmetryElement(1, 2, 0, 3, 4);
        HashSet<SymmetryElement> verStabilizer = SymmetryElement.CyclicGroup(verRotation);
        /*new HashByString<SymmetryElement>();
        verStabilizer.Add(SymmetryElement.Identity(5));
        verStabilizer.Add(verRotation);
        verStabilizer.Add(verRotation * verRotation);*/
        HashSet<SymmetryElement> verCosets = SymmetryElement.CosetRepresentatives(fullGroup, verStabilizer);

        Dictionary<SymmetryElement, int> cosetRepToIndex = new Dictionary<SymmetryElement, int>(SymmetryElement.comparer);

        Debug.Log("Vertex cosets:");
        //float[] point4 = new float[] { 1, 1, 1, -3 };
        float[] point5 = new float[] { 1, 1, 1, 0, -3f };
        foreach (var cosetRep in verCosets)
        {
            Vector3 verPosition = ProjOfAug5to4(cosetRep.Apply(point5)) * radius;
            cosetRepToIndex.Add(cosetRep, AddVertex(verPosition, cosetRep.ToString()));
            Debug.Log(cosetRep);
        }

        //SymmetryElement faceRotation = new SymmetryElement(0, 2, 3, 1);
        SymmetryElement faceRotation = new SymmetryElement(3, 4, 0, 1, 2);
        HashSet<SymmetryElement> faceStabilizer = SymmetryElement.CyclicGroup(faceRotation);
        HashSet<SymmetryElement> faceCosets = SymmetryElement.CosetRepresentatives(fullGroup, faceStabilizer);

        Debug.Log("Face cosets:");
        foreach (var faceCoset in faceCosets)
        {
            Debug.Log(faceCoset);
        }

        foreach (var faceCoset in faceCosets)
        {
            List<int> faceVertexIndices = new List<int>();
            foreach (var elem in faceStabilizer)
            {
                SymmetryElement verRep = SymmetryElement.FindCosetRepresentative(faceCoset * elem, verCosets, verStabilizer);
                if (!cosetRepToIndex.TryGetValue(verRep, out int index))
                {
                    Debug.Log("You should not be here");
                    return;
                }
                faceVertexIndices.Add(index);
            }
            AddFace(faceVertexIndices, null, Vector3.zero);
        }

        /*
        //return;
        float[] point4 = new float[] { -2, -1, 1, 2 };
        // The subgroup generated by (0,1,2)(3) fixes the point above,
        // so that 
        SymmetryElement ss = new SymmetryElement(1, 2, 3, 0);
        SymmetryElement rr = new SymmetryElement(1, 2, 0, 3);
        SymmetryElement g = rr * ss * ss * ss;
        g.Apply(point4);
        Vector3[] vv = new Vector3[]
        {
            Aug4to3(point4),
            Aug4to3(ss.Apply(point4)),
            Aug4to3((ss * ss).Apply(point4)),
            Aug4to3((ss * ss * ss).Apply(point4)),
            Aug4to3(rr.Apply(point4)),
            Aug4to3((rr * ss).Apply(point4)),
            Aug4to3((rr * ss * ss).Apply(point4)),
            Aug4to3((rr * ss * ss * ss).Apply(point4)),
        };*/

    }

}



public class ToStringComparer<T> : IEqualityComparer<T>
{

    public bool Equals(T x, T y)
    {
        return x.ToString() == y.ToString();
    }

    public int GetHashCode(T obj)
    {
        return obj.ToString().GetHashCode();
    }
}

public class HashByString<T> : HashSet<T>
{


    private static ToStringComparer<T> comparer = new ToStringComparer<T>();

    public HashByString() : base(comparer) {
    }
}

public class SymmetryElement
{
    /// <summary>
    /// Looks for a represntative g such that element*subgroup == g*subgroup.
    /// </summary>
    /// <param name="element"></param>
    /// <param name="cosetsRep"></param>
    /// <param name="subgroup"></param>
    /// <returns></returns>
    public static SymmetryElement FindCosetRepresentative(
        SymmetryElement element, HashSet<SymmetryElement> cosetsRep, HashSet<SymmetryElement> subgroup)
    {
        if (element == null)
            return element;
        SymmetryElement inverseElement = element.Inverse();
        foreach (var representative in cosetsRep)
        {
            if (subgroup.Contains(inverseElement * representative))
            {
                return representative;
            }
        }
        return null;
    }

    public static HashSet<SymmetryElement> CosetRepresentatives(
        HashSet<SymmetryElement> fullGroup, HashSet<SymmetryElement> subGroup)
    {
        HashByString<SymmetryElement> representatives = new HashByString<SymmetryElement>();
        foreach (SymmetryElement element in fullGroup)
        {
            if (FindCosetRepresentative(element, representatives, subGroup) == null)
                representatives.Add(element);
            /*bool represented = false;
            foreach (var representative in representatives)
            {
                SymmetryElement inverse = representative.Inverse();
                if (subGroup.Contains(element * inverse))
                {
                    represented = true;
                    break;
                }
            }

            if (!represented)
                representatives.Add(element);*/
        }
        return representatives;
    }

    public static HashSet<SymmetryElement> CyclicGroup(SymmetryElement element)
    {
        HashSet<SymmetryElement> cyclicGroup = new HashByString<SymmetryElement>();
        SymmetryElement current = element;
        for (int i = 0; i < 100; i++) // just to avoid infinite loops! TODO
        {
            cyclicGroup.Add(current);
            if (current.IsIdentity())
                return cyclicGroup;

            current *= element;
        }

        return null; // should not get here

    }

    public static ToStringComparer<SymmetryElement> comparer = new ToStringComparer<SymmetryElement>();

    public static SymmetryElement Identity(int n)
    {
        int[] images = new int[n];
        for (int i = 0; i < n; i++)
        {
            images[i] = i;
        }
        return new SymmetryElement(images);
    }

    public static HashByString<SymmetryElement> FullGroup(int n)
    {
        HashByString<SymmetryElement> elements = new HashByString<SymmetryElement>();

        int[] source = new int[n];
        for (int i = 0; i < n; i++)
        {
            source[i] = i;
        }
        foreach (var permutation in Permutations(source, n))
        {
            elements.Add(new SymmetryElement(permutation)); // make copies? TODO
        }

        return elements;
    }

    public static HashByString<SymmetryElement> AlternatingGroup(int n)
    {
        HashByString<SymmetryElement> alternatingSubgroup = new HashByString<SymmetryElement>();
        foreach (var permutation in FullGroup(n))
        {
            if (permutation.parity == 1)
                alternatingSubgroup.Add(permutation);
        }

        return alternatingSubgroup;
    }

    private static void SwitchElem(int[] source, int i, int j)
    {
        (source[j], source[i]) = (source[i], source[j]);
    }

    private static IEnumerable<int[]> Permutations(int[] source, int largestIndex)
    {
        for (int i = 0; i < largestIndex; i++)
        {
            SwitchElem(source, i, largestIndex - 1);
            foreach (var permutation in Permutations(source, largestIndex - 1))
            {
                yield return permutation;
            }
            SwitchElem(source, i, largestIndex - 1);
        }
        if (largestIndex == 0)
            yield return source;
    }

    private readonly int[] images;
    private string cycleString;
    private int parity;

    public SymmetryElement(params int[] images)
    {
        this.images = new int[images.Length];
        Array.Copy(images, this.images, images.Length);
        parity = 1;
        cycleString = "";
        bool[] visited = new bool[images.Length];
        for (int i = 0; i < images.Length; i++)
        {
            visited[i] = false;
        }
        for (int i = 0; i < images.Length; i++)
        {
            if (visited[i])
                continue;
            cycleString += $"({i}";
            visited[i] = true;
            int next = At(i);
            while (next != i)
            {
                visited[next] = true;
                cycleString += $",{next}";
                next = At(next);
                parity *= -1;
            }
            cycleString += $") ";
        }
    }

    public int Size()
    {
        return images.Length;
    }

    public float[] Apply(params float[] v)
    {
        float[] result = new float[images.Length];
        for (int i = 0; i < images.Length; i++)
        {
            result[i] = v[At(i)];
        }
        return result;
    }

    public static SymmetryElement operator *(SymmetryElement elem1, SymmetryElement elem2)
    {
        int n = elem1.Size();
        if (n != elem2.Size())
            return null;
        int[] images = new int[n];
        for (int i = 0; i < n; i++)
        {
            images[i] = elem1.At(elem2.At(i));
        }
        return new SymmetryElement(images);
    }

    public static SymmetryElement operator *(SymmetryElement elem1, int n)
    {
        return null;
    }

    public int At(int i)
    {
        return images[i];
    }

    public bool IsIdentity()
    {
        for (int i = 0; i < images.Length; i++)
        {
            if (At(i) != i)
                return false;
        }
        return true;
    }

    public SymmetryElement Inverse()
    {
        int[] inverseImages = new int[Size()];
        for (int i = 0; i < inverseImages.Length; i++)
        {
            inverseImages[At(i)] = i;
        }
        return new SymmetryElement(inverseImages);
    }

    override public String ToString()
    {
        return cycleString;
    }

}